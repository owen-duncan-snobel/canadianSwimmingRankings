{"ast":null,"code":"// * Finds the element in an Array returns a Map (key,value) of the number of occurences of each distinctive element \nexport const mostOccurences = list => {\n  let map = new Map();\n\n  while (list.length !== 0) {\n    if (!map.has(list[0])) {\n      map.set(list[0], 1);\n    } else {\n      map.set(list[0], map.get(list[0]) + 1);\n    }\n\n    list.shift();\n  }\n\n  return map;\n}; // * Average and Median Times\n\nexport const averageTime = time => {\n  try {\n    let average = time.reduce((a, b) => a + b);\n    return new Date(average / time.length).toISOString().substr(14, 8);\n  } catch {\n    console.log('Error: Empty Data Array');\n  }\n};\nexport const medianTime = time => {\n  try {\n    let index = Math.floor(time.length / 2);\n    let median; // * If the length % 2 === 0 (aka even number)\n\n    if (time.length % 2 === 0 && time.length !== 0) {\n      // * Minus one is needed for correct array index of even number centre points\n      median = (time[index - 1] + time[index]) / 2;\n    } else if (time.length % 2 === 1) {\n      median = time[index];\n    }\n\n    return new Date(median).toISOString().substr(14, 8);\n  } catch {\n    console.log('Error: Empty Data Array');\n  }\n};\nexport const modeTime = time => {\n  try {\n    // * Times is given in Milliseconds, and from lowest to highest. We will convert to seconds and round down to standardize mode to seconds\n    let toModeSeconds = time.map(el => Math.floor(el / 1000));\n    let modeOccurence = mostOccurences(toModeSeconds); // * Iterates through the map and finds the most occuring time\n\n    let mostCommonNumber = NaN;\n    let maxCount = -1;\n\n    for (let [num, count] of modeOccurence.entries()) {\n      if (count > maxCount) {\n        maxCount = count;\n        mostCommonNumber = num;\n      }\n    }\n\n    return {\n      mostCommonNumber,\n      maxCount\n    };\n  } catch {\n    console.log('Error: Empty Data Array');\n  }\n};","map":{"version":3,"sources":["/Users/owen/Desktop/Selenium_Scraping_Js/SwimCanada/Puppeteer_Scraping_SwimCanada/swim-app/src/constants/swimAnalytics/swimAnalytics.js"],"names":["mostOccurences","list","map","Map","length","has","set","get","shift","averageTime","time","average","reduce","a","b","Date","toISOString","substr","console","log","medianTime","index","Math","floor","median","modeTime","toModeSeconds","el","modeOccurence","mostCommonNumber","NaN","maxCount","num","count","entries"],"mappings":"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","sourcesContent":["// * Finds the element in an Array returns a Map (key,value) of the number of occurences of each distinctive element \nexport const mostOccurences = (list) => {\n    let map = new Map();\n    while (list.length !== 0) {\n        if (!map.has(list[0])) {\n            map.set(list[0], 1);\n        } else {\n            map.set(list[0], map.get(list[0]) + 1);\n        }\n        list.shift();\n    }\n    return map;\n};\n\n\n// * Average and Median Times\nexport const averageTime = (time) => {\n    try {\n        let average = time.reduce((a, b) => a + b);\n        return new Date(average / time.length).toISOString().substr(14, 8);\n    }\n    catch {\n        console.log('Error: Empty Data Array')\n    }\n}\n\nexport const medianTime = (time) => {\n    try {\n        let index = Math.floor(time.length / 2);\n        let median;\n        // * If the length % 2 === 0 (aka even number)\n        if (time.length % 2 === 0 && time.length !== 0) {\n            // * Minus one is needed for correct array index of even number centre points\n            median = (time[index - 1] + time[index]) / 2;\n        } else if (time.length % 2 === 1) {\n            median = time[index];\n        }\n        return new Date(median).toISOString().substr(14, 8)\n    } catch {\n        console.log('Error: Empty Data Array')\n    }\n}\n\n\nexport const modeTime = (time) => {\n    try {\n        // * Times is given in Milliseconds, and from lowest to highest. We will convert to seconds and round down to standardize mode to seconds\n        let toModeSeconds = time.map(el => Math.floor(el / 1000));\n        let modeOccurence = mostOccurences(toModeSeconds);\n\n        // * Iterates through the map and finds the most occuring time\n        let mostCommonNumber = NaN\n        let maxCount = -1\n        for (let [num, count] of modeOccurence.entries()) {\n            if (count > maxCount) {\n                maxCount = count\n                mostCommonNumber = num\n            }\n        }\n        return { mostCommonNumber, maxCount };\n    } catch {\n        console.log('Error: Empty Data Array')\n    }\n}"]},"metadata":{},"sourceType":"module"}